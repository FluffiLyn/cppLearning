## Chapter 6: Priority Queues(Heaps)

### 6.1 Model
优先队列是一种特殊的队列，其中每个元素都有一个优先级。优先级最高的元素最先出队。

例如：要找到元素集合中的最小（最大）元素，可以使用优先队列。

如果最小值拥有最高优先级，则称为升序优先队列；如果最大值拥有最高优先级，则称为降序优先队列。

### 6.2 优先队列主要操作
至少有两种操作：
* insert()：等价于enqueue()
* deleteMin()：等价于dequeue()

### 6.3 实现工具：二叉堆
链表的时间复杂度为O(N)；二叉搜索树的时间复杂度为O(logN)，但是多了很多不必要的操作。

我们将使用**二叉堆（binary heap）**。二叉堆是一种完全二叉树，其中**每个节点的值都小于等于（或大于等于）其子节点的值**。

#### 6.3.1 结构性质
时间复杂度：因为完全二叉树的高是$\left\lfloor  logN\right\rfloor$，所以二叉堆的时间复杂度为O(logN)。

此外，由于二叉堆有一定规律，所以可以用一个**数组**表示。规律如下：（以1为起始索引）
* 对于数组中i位置的元素，左子节点在2i，右子节点在2i+1，父节点在$\left\lfloor  i/2\right\rfloor$处。

#### 6.3.2 堆序性质
使操作能被快速执行的性质是堆序性质。

对于一个最小堆的树，其最小值在根节点上。由于任意子树也是最小堆，所以任意节点应小于它的所有后裔。

因此，findMin()的时间复杂度为O(1)。

#### 6.3.3 基本操作（以最小堆为例）
1. insert
当插入一个元素X到堆中时，它可能不满足堆的性质，在这种情况下，需要调整堆中元素的位置使之重新变成堆。

方法是：在下一个可用节点创建一个**空穴（hole）**，如果X可以放在这个空穴中，那么插入操作完成；否则，将空穴的**父节点**移动到空穴中，则空穴上升，直到X可以放在空穴中。

例如：有一个堆
```
    1
   / \
  3   4
 /
6
```
现在要插入2，插入到3的右子节点，此时插入将会破坏堆的性质。

```
     1
    / \
   3   4
  / \
 6  ()
 ```

我们创建一个空穴，将3移动到空穴中，空穴上升，直到2可以放在空穴中。
```
     1
    / \
   ()  4
  / \
 6   3 
 
     1
    / \
   2   4
  / \
 3   6 
```

这种策略被称为**上滤（percolate up）**。