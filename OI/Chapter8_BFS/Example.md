# 8. 广度优先搜索
广度优先搜索（Breadth-First Search，简称BFS）是一种用于遍历或搜索树或图的算法。它从根节点或给定的起始节点开始，逐层访问节点，即在每一层的所有节点都被访问过后才会继续访问下一层的节点。BFS利用数据结构“队列”来保存待访问节点的序列，遵循“先进先出”（First In, First Out, FIFO）原则。

以下是广度优先搜索的一般步骤：

1. 初始化：
   * 创建一个空队列，并将起始节点或根节点加入队列。
   * 标记起始节点为已访问。
   * 循环处理：

2. 循环处理
   * 当队列不为空时，执行以下操作：
        * 从队列头部取出一个节点（即最早加入队列的那个节点）。
        * 对于当前取出的节点，检查其所有尚未访问过的邻接节点：标记它们为已访问，并将这些邻接节点加入队列的尾部。
    * 如果遇到目标节点（比如在寻找特定节点或路径的任务中），则结束搜索并返回结果。
3. 搜索结束：
    * 如果队列变空且目标节点未找到，则表示在所搜索的范围内没有找到目标节点。

广度优先搜索常用于解决一些问题，如在网络中寻找最短路径（当所有边权重相等时）、在无权图中查找两点间的最短路径、在树或图中验证两节点间是否存在连接路径等。同时，在网络爬虫中，BFS也被用来实现网页抓取的层级策略。

算法描述：
```
int bfs
{
    init();//初始状态存入队列
    首指针head = 0， 尾指针tail = 1;
    while (head < tail)
    {
        head后移一位;
        for (int i = 0; i < max; i++)
        {
            if (子节点符合条件)
            {
                tail+1,将新节点存入列尾;
                if (新节点与原节点重复) 删除节点;//取消入队，tail-1
                    else if (新节点是目标节点)
                    {
                        cout;
                        return;
                    }
                else continue;
            }
        }
    }
}
```
## 8.1 注意事项
1. 每生成一个子节点就必须提供指向其父节点的指针。当解出现时，通过逆向跟踪找到从根节点到目标节点的一条路径。
2. 生成的节点要与前面所有已产生的节点比较，以免出现重复节点，浪费时间和空间，还可能陷入死循环。
3. 何时使用：
   * 若目标节点的深度与"费用"（如路径长度）成正比时，找到的第一个解就是最优解，比DFS快。
   * BFS的效率还依赖于目标节点的位置。若目标节点较深，则需搜索的节点呈指数增长

## 8.2 交通路线选择
```c++
#include <iostream>
#include <string>
using namespace std;

//1表示不可走，0表示可走
int ju[8][8]={{1,0,0,0,1,0,1,1},
             {0,1,1,0,0,1,1,1},
             {0,1,1,0,0,1,1,1},
             {0,1,0,1,1,1,0,1},
             {1,1,0,1,1,1,0,0},
             {0,0,1,1,1,1,1,0},
             {1,1,1,0,0,1,1,0},
             {1,1,1,1,0,0,0,1}};
int queue[101] = {0}, before[101] = {0};//queue时存储扩展节点的队列，记录经过的城市；before记录前趋城市 
bool s[8] = {0};//记录该城市已到过
void output(int d)
{
    cout << char(queue[d] + 65);
    while (before[d])
    {
        d = before[d];
        cout << "--" << char(queue[d] + 65);
    }
    cout << endl;
}

void bfs()
{
    int head = 0, tail = 1;
    queue[0] = 1; before[0] = 0; s[0] = 1;

    do
    {
        head++;
        for (int i = 0; i < 8; i++)
        {
            if (ju[queue[head]][i] == 0 && s[i] == 0)
            {
                tail++;
                queue[tail] = i;
                before[tail] = head;
                s[i] = 1;
                
                //搜索到H城市时：
                if (i == 7) 
                {
                    output(tail);
                    head = tail;
                    break;
                }
            }
        }
    }while(head < tail);
}

int main()
{
    bfs();

    return 0;
}
```
为什么要在do后面head++？

在上述C++代码中，head变量代表队列的头部，初始化为0。在每次循环开始时，先执行head++操作的原因是为了让head指向下一个待处理的节点。

在广度优先搜索（BFS）算法中，队列（这里用数组queue模拟）按照“先进先出”（FIFO）的原则组织节点的访问顺序。初始时，我们将起始节点放入队列中，并将head设为0。当进入循环体时，我们需要移动队列头部到下一个节点以便进行处理，这是因为我们已经在上一轮循环中处理过了头部节点。

所以，head++的操作实际上是“消费”了队列中的第一个节点，意味着我们准备处理队列中的下一个节点，也就是之前入队的第一个节点的下一个未访问过的邻居节点。这样就能保证按照广度优先的策略逐层遍历图中的节点。