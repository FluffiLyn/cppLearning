# 8. 广度优先搜索
广度优先搜索（Breadth-First Search，简称BFS）是一种用于遍历或搜索树或图的算法。它从根节点或给定的起始节点开始，逐层访问节点，即在每一层的所有节点都被访问过后才会继续访问下一层的节点。BFS利用数据结构“队列”来保存待访问节点的序列，遵循“先进先出”（First In, First Out, FIFO）原则。

以下是广度优先搜索的一般步骤：

1. 初始化：
   * 创建一个空队列，并将起始节点或根节点加入队列。
   * 标记起始节点为已访问。
   * 循环处理：

2. 循环处理
   * 当队列不为空时，执行以下操作：
        * 从队列头部取出一个节点（即最早加入队列的那个节点）。
        * 对于当前取出的节点，检查其所有尚未访问过的邻接节点：标记它们为已访问，并将这些邻接节点加入队列的尾部。
    * 如果遇到目标节点（比如在寻找特定节点或路径的任务中），则结束搜索并返回结果。
3. 搜索结束：
    * 如果队列变空且目标节点未找到，则表示在所搜索的范围内没有找到目标节点。

广度优先搜索常用于解决一些问题，如在网络中寻找最短路径（当所有边权重相等时）、在无权图中查找两点间的最短路径、在树或图中验证两节点间是否存在连接路径等。同时，在网络爬虫中，BFS也被用来实现网页抓取的层级策略。

算法描述：
```
int bfs
{
    init();//初始状态存入队列
    首指针head = 0， 尾指针tail = 1;
    while (head < tail)
    {
        head后移一位;
        for (int i = 0; i < max; i++)
        {
            if (子节点符合条件)
            {
                tail+1,将新节点存入列尾;
                if (新节点与原节点重复) 删除节点;//取消入队，tail-1
                    else if (新节点是目标节点)
                    {
                        cout;
                        return;
                    }
                else continue;
            }
        }
    }
}
```
## 8.1 注意事项
1. 每生成一个子节点就必须提供指向其父节点的指针。当解出现时，通过逆向跟踪找到从根节点到目标节点的一条路径。
2. 生成的节点要与前面所有已产生的节点比较，以免出现重复节点，浪费时间和空间，还可能陷入死循环。
3. 何时使用：
   * 若目标节点的深度与"费用"（如路径长度）成正比时，找到的第一个解就是最优解，比DFS快。
   * BFS的效率还依赖于目标节点的位置。若目标节点较深，则需搜索的节点呈指数增长

## 8.2 交通路线选择
