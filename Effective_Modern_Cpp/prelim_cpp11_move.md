# C++11 移动语义详解
文章来源：[透彻理解C++11 移动语义：右值、右值引用、std::move、std::forward](https://www.cnblogs.com/KillerAery/p/12802771.html)
## 回顾浅拷贝与深拷贝
**浅拷贝**：只复制指针地址，多个对象共享同一块动态资源，可能导致重复释放内存。

**深拷贝**：复制指针地址以及动态资源，每个对象拥有独立的资源，避免资源冲突。

但是深拷贝开销很大！那么什么对象在被拷贝后可以保证不再访问这块内存呢？答案是**临时对象**。

## 左值和右值（C++98）
* 左值（lvalue）：表达式结束后依然存在的持久对象。
* 右值（rvalue）：表达式结束后就不再存在的临时对象。

* 更直观的理解是：有变量名的对象都是左值，没有变量名的都是右值。（因为有无变量名意味着这个对象是否在下一行代码时依然存在）
  * 值得注意的是，**字符字面量**是唯一不可算入右值的字面量，因为它实际存储在**静态内存区**，是**持久**存在的。
* 对于判断一个表达式是否是左值，一个方法是尝试取得它的地址。如果能取地址，那么通常就是左值；反之，则通常是右值。

## 右值引用类型
C++11引入了右值引用类型&&，负责匹配右值；左值引用&则负责匹配左值。

#### 类型和左值/右值
一个表达式的**类型**与它是左值还是右值无关。例如：
```cpp
class Widget {
public:
    Widget(Widget&& rhs);   //rhs是个左值，
    …                       //尽管它有个右值引用的类型
};

Widget::Widget(Widget&& rhs) {// 自己实现的函数
    this->data = rhs.data; // 可以访问 rhs 的成员
    rhs.data = nullptr;   // 可以修改 rhs
}
```
右值引用类型只是用于**匹配右值**，而并非表示一个右值。因此，即使rhs的**类型**是右值引用，它却因为有变量名，仍然是一个左值。


C++11定义：
* 左值（lvalue）：持久存在（有变量名）的对象或返还值类型为左值引用的返还值，是不可移动的。
* 右值（rvalue）：包含了**将亡值（xvalue）**、**纯右值（prvalue）**，是可移动（可被右值引用类型匹配）的值。

`std::move()`是c++11提供的函数，将其参数转换为右值引用，从而允许移动构造函数或移动赋值运算符接管资源，而不是复制它们。因此Widget的移动构造函数可以这样实现：
```cpp
Widget::Widget(Widget&& rhs) {
    this->data = std::move(rhs.data); // 调用 std::move() 将 rhs.data 转换为右值
}
```

to be continued...